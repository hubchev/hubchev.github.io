# How to work with R scripts 


## R Scripts: Why they are useful

Typing functions into the console to run code may seem simple, but this interactive style has limitations:

- Typing commands one at a time can be cumbersome and time-consuming.
- It's hard to save your work effectively.
- Going back to the beginning when you make a mistake is annoying.
- You can't leave notes for yourself.
- Reusing and adapting analyses can be difficult.
- It's hard to do anything except the basics.
- Sharing your work with others can be challenging.

That's where having a transcript of all the code, which can be re-run and edited at any time, becomes useful. An R script is precisely that - a plain text file that contains code and comments and this comes with advantages:

- Scripts provide a record of everything you did during your data analysis.
- You can easily edit and re-run code in a script.
- Scripts allow you to leave notes for yourself.
- Scripts make it easy to reuse and adapt analyses.
- Scripts allow you to do more complex analyses.
- Scripts make it easy to share your work with others.


## Generate, write and run R scripts

To __generate a script__ you can 

1. Go to the _File_ menu, select _New File_ and then choose _R Script_ or
2. Use the keyboard shortcut _Ctrl+Shift+N_ (Windows) or _Cmd+Shift+N_ (Mac) or
3. Type the following command in the Console: 

```{r, eval=FALSE}
file.create("hello.R")
```

In the first two ways, a new R script window will open which can be edited and should be saved either by clicking on the _File_ menu and selecting _Save_, clicking the disk icon, or by using the shortcut _Ctrl+S_ (Windows) or _Cmd+S_ (Mac).
If you go for the third way, you need to open it manually.

Regardless of your preferred way of generating a script, we can now start __writing__ our first script:

```{r, eval=TRUE}
setwd("/home/sthu/Documents/scr/")
x <- "hello world"
print(x)
``` 
Then save the script using the menus (File > Save) as hello.R.

The above lines of code do the following:

- `setwd()` allows to set the working directory. If you are not familiar with file systems, please read section \@ref(#sec:navigation) in the appendix.
- With the assignment operator `<-` we create an object that stores the words "hello world" in an object entitled `x`. In the next section \@ref(sec:assignmentoper) the assignment operator is further explained.
- With the third input we print the content of the object `x`.
  
  
So how do we __run the script__? Assuming that the `hello.R` file has been saved to your working directory, then you can run the script using the following command:

```{r eval=FALSE}
source( "hello.R" )
```

Suppose you saved the script in a sub-folder called \texttt{scripts} of your working directory, then you need to run the script using the following command:
```{r eval=FALSE}
source("./scripts/hello.R") 
```
Just note that `.' means the current folder. 
Instead of using the `source` function, you can click on the `source` button in Rstudio. 

With the character `#` you can write a comment in a script and R will simply ignore everything that follows in that line onwards. 


## The assignment operator: `<-` {#sec:assignmentoper}

Suppose I'm trying to calculate how much money I'm going to make from this book. I agree, it is an unrealistic example but it will help you to understand R. 
Let's assume I'm only going to sell 350 copies. To create a variable called `sales` that assign a \keyterm{value` to my variable `sales`, we need to use the _assignment operator_ of R, which is `<-` as follows:
```{r eval=TRUE}
sales <- 350
```
When you hit enter, R doesn't print out any output. If you are using Rstudio, and the _environment panel_ you can see that something happened there, can you? It just gives you another command prompt. However, behind the scenes R has created a variable called `sales` and given it a value of `350`. You can check that this has happened by asking R to print the variable on screen. And the simplest way to do that is to type the name of the variable and hit enter.
```{r eval=TRUE}
sales
```
Worth a mentioning is the curious features of R that there are several different ways of making assignments. In addition to the `<-` operator, we can also use `->` and `=`. If you want to use `->`, you might expect from just looking at the symbol you should write it like this:
```{r eval=TRUE}
350 -> sales
```
However, it is common practice to use `<-` and I recommend only to use this one because it is easier to read in scripts.

## Doing calculation in scripts

R can do any kind of arithmetic calculation with the arithmetic operators given in the table below. Using the assignment operator, R functions, and the features of a R script is easy and gives an idea how R works and how you should embrace the power of the programming language. 

| operation | operator | example input | example output |
| :--- | :---: | :---: | :---: |
| addition | + | 10+2 | 12 |
| subtraction | - | 9-3 | 6 |
| multiplication | * | 5*5 | 25 |
| division | / | 10/3 | 3 |
| power | - | 5-2 | 25 |

So please copy and past the following script, try to run it on your PC, and try to understand it. Of course, you have to tweak the script a bit to make it run on your PC. For example, I doubt you have the same working directory that I decided to use.

```{r eval=TRUE}
# Set working directory
setwd("~/Dropbox/hsf/23-ss/ds")
# Create a vector that contains the sales data
sales_by_month <- c(0, 100, 200, 50, 3, 4, 8, 0, 0, 0, 0, 0)
sales_by_month
sales_by_month[2]
sales_by_month[4]
february_sales <- sales_by_month[2]
february_sales
sales_by_month[5] <- 25 # added May sales data
sales_by_month
# Do I have 12 month?
length( x = sales_by_month )
# Assume each unit costs 7 Euro, then the revenue is
price <- 7
revenue <- sales_by_month*price
revenue
# To get statistics for daily revenue we define the number of days:
days_per_month <- c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
# Calculate the daily revenue
revenue_per_day <- revenue/days_per_month
revenue_per_day 
# round number 
round(revenue_per_day) 
```

Use the "`?`" to search for the documentation of all functions used. In particular, do you understand how the function `round()` works? What arguments does the function contain? How can you manipulate the pre-defined arguments. For example, can you calculate the rounded revenue per day with two or four digits? Try it out!

```{r eval=FALSE}
?round()
```


### User-defined functions {#sec:generics}

One of the great strengths of R is the user's ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations it can be helpful to create your own custom function. The structure of a function is given below:

```{r eval=FALSE}
name_of_function <- function(argument1, argument2) {
    statements or code that does something
    return(something)
}
```

First you give your function a name.
Then you assign value to it, where the value is the function.
When defining the function you will want to provide the list of arguments required (inputs and/or options to modify behavior of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments. The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it's not necessary to define what it is in any way.
Finally, you can return the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function -- they don't exist outside of the function. Note, a function doesn't require any arguments.

Let's try creating a simple example function. This function will take in a numeric value as input, and return the squared value.
```{r eval=T}
square_it <- function(x) { 
   square <- x * x
   return(square)
} 
```

Now, we can use the function as we would any other function. We type out the name of the function, and inside the parentheses we provide a numeric value `x`:

```{r eval=T}
square_it(5)
```

Let us get back to script with sales and try to calculate the monthly growth rates of revenue using a self-written function.

The formula of a growth rate is clear:

$$g=\left(\frac{y_t-y_{t-1}}{y_{t-1}}\cdot 100\right)=\left(\frac{y_t}{y_{t-1}}-1\right)\cdot 100$$
So the challenge is to divide the value of `revenue` with the value of the previous period, a.k.a. the lagged value. Let us assume that the function `lag()` can give you exactly that value of a vector. Lets try it out:

```{r include=FALSE}
detach("package:dplyr")
```


```{r eval=T}
lag(revenue)
(revenue/lag(revenue)-1)*100 
```

Unfortunately, this does not work out. The `lag()` function does not work as we think it should. Well, the reason is simply that we are using the wrong function. The current `lag()` function is part of the stats package which is part of R base and is always loaded. The `lag()` function we aim to use stems from the dplyr package which we must install and load to be able to use it. So let's do it:

```{r eval=T}
# check if the package is installed
find.package("dplyr")
# I already installed the package so I can just load it
# install.packages("dplyr")
library("dplyr")
```
Now, we was informed that among other functions the `lag()` function is _masked_. That means that now the function of the newly loaded package is active. So, let's try again:
```{r eval=T}
lag(revenue)
(revenue/lag(revenue)-1)*100 
```
That looks good now. And here is a way to calculate growth rates with a self-written function:
```{r eval=T}
growth_rate <- function(x)(x/lag(x)-1)*100 
growth_rate(revenue)
sales_gr_rate <- growth_rate(revenue)
sales_gr_rate
```

You know, all functions in R are user-written and sometimes it happens that two people had the idea to name functions identically. In such a case we have to deal with that conflict as we cannot use both functions at the same time. Also, it is a very realistic case that you find a solution somewhere that should work out your problem but you fail to make it run. In such a case it is often a forgotten package that needs to be loaded.






